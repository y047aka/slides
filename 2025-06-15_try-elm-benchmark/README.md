# Elmのパフォーマンス、実際どうなの？ベンチマークに入門してみた

こんにちは、Yoshitaka Totsukaです。
本日は「Elmのパフォーマンス、実際どうなの？ベンチマークに入門してみた」というタイトルでお話しさせていただきます。

## 発表の流れ

今日はこんな感じで話していきます。

## Elm の紹介

ではElmの紹介に進みます。
Elmの特徴をたくさん書き出してみました。
2021年にリリースされた0.19から言語としての大きなバージョンアップこそないものの、安全で保守しやすいWebアプリケーションを開発するための充分な機能を備えています。
この数年間は言語自体のバージョンアップが少ない代わりに、不足する機能を周辺フレームワークのサポートで補う形で引き続き発展を続けていました。
Web開発においてはTypeScriptとそのエコシステムが発展し絶対的なポジションを確立していることは認めざるを得ませんが、AIを活用した開発が進む中でこれまでのデメリットが解消されてより快適な開発ができているようにも感じます。

なんと、関数型まつりのWebサイトもelmで実装しています。

## elm-motorsport-analysis

今回ベンチマークの対象とするのは、私が自分用に開発している`elm-motorsport-analysis`というアプリケーションです。

このアプリケーションは、モータースポーツの周回データを分析・可視化するためのツールです。主な機能として、CSVファイルから車両の周回データを読み込み、各車両の順位変動、ラップタイム分析、セクタータイム比較などを提供しています。

実装にはThe Elm Architectureを採用しており、関数型プログラミングのパラダイムに基づいた安全で保守しやすいコードベースとなっています。データ処理部分では大量の周回データを扱うため、パフォーマンスが重要な要素となります。

## ベンチマーク測定の動機

まず、今回のベンチマーク測定に取り組んだ動機についてお話しします。
主に好奇心からです。`List` と `Array` のパフォーマンスの違いを体感してみたいという気持ちがありました。
また、非効率なコードが残っているうちに試してみたいと考えました。
というのも、改善の幅が大きいほうが楽しいですし、アプリケーションの機能追加を予定していたので、その前に挑戦したいと思ったからです。

## ベンチマーク測定の方法

それでは、ベンチマーク測定の方法について説明させていただきます。

まず、ベンチマークテストの概要についてです。
ベンチマークテストの主な目的は、システムの性能を評価することです。
また、異なる実装アプローチでの性能を比較したり、ボトルネックを特定したりすることも目的の一つです。

次に、ベンチマーク測定時の注意事項についてです。
ベンチマークを実施するにあたって、同じ条件で測定すれば、常に同じ結果が得られるようにすることが重要です。
具体的には、測定環境の統一として、CPU、メモリ、ネットワーク環境などの条件を揃える必要があります。
また、統計的な有意性を確保するため、十分なサンプル数の確保と外れ値の除外が重要です。

## elm-explorations/benchmark

では、実際に使用したベンチマークツールについて説明します。Elmコードのベンチマークを実行するためのパッケージとして、elm-explorations/benchmarkを使用しました。

このパッケージは、前述したベンチマーク測定時の注意点を自動的に解決してくれます。

まず、測定環境の最適化です。
このパッケージでは測定前にJITコンパイルを強制し、最適化あり/なしのコードが混在するのを防ぎます。

また、統計的に有意な結果を提供します。
十分なサンプル数を得るまで反復実行し、複数対象を交互に実行することで測定の偏りを軽減します。
外れ値を除外する機能も備えています。

このように簡潔にベンチマークを定義でき、elm-explorations/benchmarkがベンチマーク測定時の複雑な処理を自動的に行ってくれます。

## ベンチマーク測定してみよう！

それでは、実際にベンチマークを実施したelm-motorsport-analysisアプリケーションについて、技術的な詳細をご説明します。

### データ処理の流れ

最初に、データ処理の全体的な流れについて説明します。

1. CSVデータの読み込み＆デコード
   - ル・マン24時間レース（2024年）の走行データを使用しました
   - このCSVデータを、Elmで扱いやすい周回データ（Lap型）としてデコードします
   
2. データの前処理（preprocess）
   - デコードしたデータを車両単位で再構成します
   - 計算量の多い分析を最初に済ませておく（preprocessHelper）ことで、後の処理を高速化します

### CSVをパースし、周回データとしてデコード

具体的な実装を見ていきましょう。周回データを解析し、車両単位で再構成する処理は以下のような形になっています

### ベンチマーク結果

この初期実装のベンチマーク結果は以下の通りです：

- **preprocess関数**
  - 10件のデータ：67,307回/秒（GoF: 99.99%）
  - 100件のデータ：1,272回/秒（GoF: 99.99%）
  - ※1,000件、5,000件では処理速度が大幅に低下

- **preprocessHelper関数**
  - 375回/秒（GoF: 100%）

このベンチマーク結果から、データ量が増えるにつれて処理速度が大幅に低下することが分かりました。

### パフォーマンス改善のアイデア

このベンチマーク結果を受けて、パフォーマンス改善のために以下のアイデアを検討しました：

#### 大量データの処理による線形時間の増加

- `List` を `Array` に置き換える
  - インデックスアクセスに強いArrayの特性を活用
- `AssocList` による線形検索（O(n)）を `Dict` に置き換える
  - ハッシュテーブルベースの定数時間検索（O(1)）を活用

#### 非効率な計算の繰り返し

- 計算ロジックを見直す
  - 重複計算の排除
  - 中間結果の再利用

## 改善①：List を Array に置き換える

まず、`List` を `Array` に置き換えることを考えました。1万行以上のデータを扱うので、Arrayの優位性を体感できるのではないかと考えたからです。

具体的なベンチマーク結果を見てみましょう。List.lengthとArray.lengthの比較では、5件のデータの場合、List.lengthが30,822,646回/秒でしたが、Array.lengthは274,508,871回/秒となりました。50件のデータでは、List.lengthが3,824,299回/秒でしたが、Array.lengthは同じ274,508,871回/秒を維持しました。500件のデータでは、List.lengthが392,379回/秒まで低下したのに対し、Array.lengthは274,955,086回/秒とほぼ同等の性能を維持しました。

このように、データ量が増えるにつれて、Arrayの優位性がより顕著になりました。

ただし、`Array`を操作する関数が不足しているという課題がありました。例えば、ソート処理を行う場合、`Array`を`List`に変換してから`List.sortBy`を使用する必要がありました。この変換処理のオーバーヘッドを考慮する必要があります。

## 改善②：AssocList を Dict に置き換える

次に、`AssocList` を `Dict` に置き換えることを検討しました。`AssocList`は線形時間、つまりO(n)が必要なのに対し、`Dict`は定数時間、つまりO(1)でのアクセスが可能です。


ベンチマーク結果では、ordersByLapの処理で、500件のデータの場合、AssocListが625回/秒でしたが、Dictは5,279回/秒となりました。また、preprocessHelperの処理でも、AssocListが349回/秒でしたが、Dictは2,215回/秒となり、大幅な改善が見られました。

## 改善③：計算ロジックを改良する

また、計算ロジックの見直しも行いました。具体的には、不要な計算の繰り返しを避け、中間結果を再利用するように改善しました。

改善前のコード：
```elm
laps_old : { carNumber : String, laps : List Wec.Lap } -> List Lap
laps_old { carNumber, laps } =
    laps
        |> List.indexedMap
            (\index { lapTime } ->
                { ...
                , best =
                    laps
                        |> List.take (index + 1)
                        |> List.map .lapTime
                        |> List.minimum
                        |> Maybe.withDefault 0
                }
            )
```

改善後のコード：
```elm
laps_improved : { carNumber : String, laps : List WecLap } -> List Lap
laps_improved { carNumber, laps } =
    let
        step : Wec.Lap -> Acc -> Acc
        step { lapTime } acc =
            let
                bestLapTime =
                    List.minimum (lapTime :: acc.bestLapTime)
            in
            { bestLapTime = bestLapTime
            , laps = currentLap :: acc.laps
            }
    in
    laps
        |> List.foldl step initialAcc
        |> .laps
        |> List.reverse
```

ベンチマーク結果は以下の通りです。
laps_の処理では、改善前が294回/秒でしたが、改善後は2,199回/秒となりました。
また、preprocessHelperの処理では、改善前が349回/秒でしたが、改善後は2,215回/秒となり、大幅な改善が見られました。

## 改善④：入力データ形式の変更

さらに、CSVからJSONへの入力データ形式の変更も検討しました。
426件のデータで比較したところ、CSVデコードが307回/秒でしたが、JSONデコードは799回/秒という結果が得られました。

## 改善⑤：その他の選択肢

最後に、その他の選択肢として、CLIアプリケーションの作成を検討しました。ElmにはUIのないヘッドレスプログラムを作成する機能があり、既存のElmのアプリケーションコードを転用できます。デコードや前処理を実行済みのJSONを出力し、それを読み込むことで、ボトルネックを解消することができました。

また、UIのパフォーマンスが問題となる場合は、Html.LazyやHtml.Keyedの活用も効果的です。これらの関数を使用することで、不要な再描画を防ぎ、パフォーマンスを向上させることができます。

## ベンチマークから得られた知見

これらの改善を実施した結果、いくつかの重要な知見を得ることができました。

### パフォーマンス最適化の原則

パフォーマンス最適化において、まず重要なのは「測定してから最適化する」ということです。推測より実測が重要です。また、段階的な改善も重要です。小さな変更を積み重ねて効果を確認していく必要があります。さらに、適切なデータ構造の選択も重要です。List、Array、Dictの使い分けを適切に行う必要があります。

### 実装から得た教訓

実装を通じて、いくつかの重要な教訓を得ました。まず、実測の価値です。ベンチマークを行うことで、予想外の結果を発見することができました。次に、シンプルさの力です。理解しやすい実装の重要性を実感しました。また、プラットフォーム理解も重要です。ElmとJavaScript VMの特性を把握することが必要です。

### The Elm Architectureでの最適化

The Elm Architectureでの最適化についても学びました。Html.LazyやHtml.Keyedの活用が重要です。また、モデル設計の見直しや、データ構造の選択も重要なポイントです。

### 自作実装の価値

自作実装を行うことで、いくつかの価値ある経験を得ることができました。まず、教育効果です。内部動作を深く理解することができました。次に、カスタマイズ性です。特定用途への最適化が可能になりました。また、関数型プログラミングの実践的な学習機会にもなりました。

## まとめ

最後に、今回の取り組みをまとめさせていただきます。

### 主な成果

今回の取り組みで、いくつかの成果を得ることができました。まず、List型を使わない完全なArray実装を実現しました。次に、ヒープソート、マージソート、クイックソートの比較を行いました。また、理論と実践の違いを体験することができました。

### 効果的な最適化アプローチ

効果的な最適化アプローチとして、段階的な改善が重要です。ListからArray、Dict、そしてロジック改善へと進めていきました。また、測定主導の開発も重要です。ベンチマークで効果を確認しながら進めました。さらに、シンプルさの価値も実感しました。可読性とパフォーマンスのバランスを取ることが重要です。

### 今後の展望

今後の展望として、より大規模データでの検証を行いたいと考えています。また、WebWorkersやWebAssemblyとの比較も興味深い課題です。さらに、実用アプリケーションでの活用も検討していきたいと思います。

サンプルコードとベンチマーク結果は、GitHubリポジトリで公開していますので、ご興味のある方はご覧ください。

ご清聴ありがとうございました。
