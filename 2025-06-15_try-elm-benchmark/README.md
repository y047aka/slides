# Elmのパフォーマンス、実際どうなの？ベンチマークに入門してみた

こんにちは、Yoshitaka Totsukaです。本日は「Elmのパフォーマンス、実際どうなの？ベンチマークに入門してみた」というタイトルでお話しさせていただきます。

## 発表の流れ

まず、発表の流れをご説明します。

1. 今回の動機について
2. Elmの簡単な紹介
3. ベンチマーク測定方法の説明
4. elm-motorsport-analysisの説明
   - サンプルデータの紹介
   - 初期実装の説明
5. そして、いくつかの最適化の試みをご紹介します
   - List を Array に置き換える
   - AssocList を Dict に置き換える
   - 計算ロジックを改良する
   - 入力データ形式の変更
   - その他の選択肢

## 今回の動機

まず、今回のベンチマーク測定に取り組んだ動機についてお話しします。主に好奇心からです。`List` と `Array` のパフォーマンスの違いを体感してみたいという気持ちがありました。また、非効率なコードが残っているうちに試してみたいと考えました。というのも、改善の幅が大きいほうが楽しいですし、アプリケーションの機能追加を予定していたので、その前に挑戦したいと思ったからです。

## Elm の紹介

それでは、Elmの紹介をさせていただきます。Elm はフロントエンド開発向けの純粋関数型言語です。主な特徴として、JavaScriptにコンパイルされるという点があります。また、型安全性が高く、Webアプリを安全に構築できるという利点があります。The Elm Architecture、略してTEAによる宣言的なUI設計が特徴的です。HaskellやOCamlなどの影響を受けつつ、シンプルな文法で学びやすい言語となっています。さらに、親切なエラーメッセージにより、開発体験が非常に良いという特徴があります。

## ベンチマークテストの概要

それでは、ベンチマークテストの概要について説明させていただきます。ベンチマークテストの主な目的は、システムの性能を評価することです。また、異なる実装アプローチでの性能を比較したり、ボトルネックを特定したりすることも目的の一つです。ベンチマークは、パフォーマンスの問題が発生したときに測定することが一般的です。

## ベンチマーク測定時の注意点

ベンチマークを実施するにあたって、いくつかの重要な点に注意が必要です。

まず、測定環境の統一が重要です。CPU、メモリ、ネットワーク環境などの条件を揃え、バックグラウンドプロセスの影響を最小化する必要があります。

次に、統計的な有意性を確保する必要があります。十分なサンプル数を確保し、外れ値を除外することが重要です。

そして、測定の再現性も重要です。同じ条件での再測定を行えば、同じ結果が得られるようにする必要があります。

## elm-explorations/benchmark

では、実際に使用したベンチマークツールについて説明します。Elmコードのベンチマークを実行するためのパッケージとして、elm-explorations/benchmarkを使用しました。

このパッケージの特徴として、まず測定前にJITコンパイルを強制する、Warming JITという機能があります。これにより、最適化されたものを使うことができます。

次に、統計的な有意性を確保するための機能があります。有意な結果を得るまで反復実行するCollecting Samplesという機能や、複数対象を交互に実行して測定の偏りを軽減する機能があります。また、測定結果の信頼性を評価する指標として、Goodness of Fitがあります。これは99%が優秀、95%が良好、90%が要注意、80%以下が信頼性低と評価されます。

## elm-motorsport-analysis

### サンプルデータ

では、実際に使用したサンプルデータについて説明します。ル・マン24時間レース（2024年）の走行データを使用しました。このデータは1万行以上のCSVファイルで、各車両の周回データが記録されています。

データの形式は以下のようになっています：
```
NUMBER; DRIVER_NUMBER; LAP_NUMBER; LAP_TIME; LAP_IMPROVEMENT; CROSSING_FINISH_LINE_IN_PIT; S1; S1_IMPROVEMENT; S2; S2_IMPROVEMENT; S3; S3_IMPROVEMENT; KPH; ELAPSED; HOUR;S1_LARGE;S2_LARGE;S3_LARGE;TOP_SPEED;DRIVER_NAME;PIT_TIME;CLASS;GROUP;TEAM;MANUFACTURER;FLAG_AT_FL;S1_SECONDS;S2_SECONDS;S3_SECONDS;
```

### 初期実装

初期実装では、このCSVデータをパースし、周回データとしてデコードした後、車両単位で再構成する処理を行いました。具体的には、以下のような実装となっていました：

```elm
preprocess : List Lap -> List Car
preprocess laps =
    laps
        |> AssocList.Extra.groupBy .carNumber
        |> AssocList.toList
        |> List.map
            (\( carNumber, laps_ ) ->
                preprocessHelper_old
                    { carNumber = carNumber
                    , laps = ...
                    , startPositions = ...
                    , ordersByLap = ...
                    }
            )
```

最初のベンチマーク結果では、10件のデータで67,307回/秒（GoF: 99.99%）、100件で1,272回/秒（GoF: 99.99%）という処理速度が得られました。しかし、1,000件以上のデータを処理する場合、処理速度が大幅に低下することが分かりました。

## 改善のアイデア

それでは、実際に行ったパフォーマンス改善のアイデアについて説明します。パフォーマンス改善のために、いくつかのアイデアを検討しました。

### 改善①：List を Array に置き換える

まず、`List` を `Array` に置き換えることを考えました。1万行以上のデータを扱うので、Arrayの優位性を体感できるのではないかと考えたからです。

具体的なベンチマーク結果を見てみましょう。`List.length`と`Array.length`の比較では：

- 5件のデータ：
  - `List.length`: 30,822,646回/秒（GoF: 99.9%）
  - `Array.length`: 274,508,871回/秒（GoF: 99.61%）
- 50件のデータ：
  - `List.length`: 3,824,299回/秒（GoF: 99.9%）
  - `Array.length`: 274,508,871回/秒（GoF: 99.61%）
- 500件のデータ：
  - `List.length`: 392,379回/秒（GoF: 99.92%）
  - `Array.length`: 274,955,086回/秒（GoF: 99.67%）

データ量が増えるにつれて、`Array`の優位性がより顕著になりました。

ただし、`Array`を操作する関数が不足しているという課題がありました。例えば、ソート処理を行う場合、`Array`を`List`に変換してから`List.sortBy`を使用する必要がありました。この変換処理のオーバーヘッドを考慮する必要があります。

### 改善②：AssocList を Dict に置き換える

次に、`AssocList` を `Dict` に置き換えることを検討しました。`AssocList`は線形検索（O(n)）が必要なのに対し、`Dict`は定数時間（O(1)）でのアクセスが可能です。

| | AssocList | Dict |
| --- | --- | --- |
| 実装 | キーと値のペアをリストで管理<br />（任意の型をキーにできる） | ハッシュベースの実装 |
| 検索速度 | O(n)<br />線形検索が必要 | O(1)<br />定数時間でのアクセスが可能 |

ベンチマーク結果では、`ordersByLap`の処理で：
- 500件のデータ：
  - `AssocList`: 625回/秒（GoF: 99.99%）
  - `Dict`: 5,279回/秒（GoF: 99.99%）

また、`preprocessHelper`の処理でも：
- `AssocList`: 349回/秒（GoF: 99.99%）
- `Dict`: 2,215回/秒（GoF: 99.95%）

と、大幅な改善が見られました。

### 改善③：計算ロジックを改良する

また、計算ロジックの見直しも行いました。具体的には、不要な計算の繰り返しを避け、中間結果を再利用するように改善しました。

改善前のコード：
```elm
laps_old : { carNumber : String, laps : List Wec.Lap } -> List Lap
laps_old { carNumber, laps } =
    laps
        |> List.indexedMap
            (\index { lapTime } ->
                { ...
                , best =
                    laps
                        |> List.take (index + 1)
                        |> List.map .lapTime
                        |> List.minimum
                        |> Maybe.withDefault 0
                }
            )
```

改善後のコード：
```elm
laps_improved : { carNumber : String, laps : List WecLap } -> List Lap
laps_improved { carNumber, laps } =
    let
        step : Wec.Lap -> Acc -> Acc
        step { lapTime } acc =
            let
                bestLapTime =
                    List.minimum (lapTime :: acc.bestLapTime)
            in
            { bestLapTime = bestLapTime
            , laps = currentLap :: acc.laps
            }
    in
    laps
        |> List.foldl step initialAcc
        |> .laps
        |> List.reverse
```

ベンチマーク結果：
- `laps_`の処理：
  - 改善前: 294回/秒（GoF: 99.99%）
  - 改善後: 2,199回/秒（GoF: 99.96%）
- `preprocessHelper`の処理：
  - 改善前: 349回/秒（GoF: 99.99%）
  - 改善後: 2,215回/秒（GoF: 99.95%）

### 改善④：入力データ形式の変更

さらに、CSVからJSONへの入力データ形式の変更も検討しました。426件のデータで比較したところ：

- CSVデコード: 307回/秒（GoF: 99.99%）
- JSONデコード: 799回/秒（GoF: 100%）

という結果が得られました。

### 改善⑤：その他の選択肢

最後に、その他の選択肢として、CLIアプリケーションの作成を検討しました。ElmにはUIのないヘッドレスプログラムを作成する機能があり、既存のElmのアプリケーションコードを転用できます。デコードや前処理を実行済みのJSONを出力し、それを読み込むことで、ボトルネックを解消することができました。

また、UIのパフォーマンスが問題となる場合は、Html.LazyやHtml.Keyedの活用も効果的です。これらの関数を使用することで、不要な再描画を防ぎ、パフォーマンスを向上させることができます。

## ベンチマークから得られた知見

これらの改善を実施した結果、いくつかの重要な知見を得ることができました。

### パフォーマンス最適化の原則

パフォーマンス最適化において、まず重要なのは「測定してから最適化する」ということです。推測より実測が重要です。また、段階的な改善も重要です。小さな変更を積み重ねて効果を確認していく必要があります。さらに、適切なデータ構造の選択も重要です。List、Array、Dictの使い分けを適切に行う必要があります。

### 実装から得た教訓

実装を通じて、いくつかの重要な教訓を得ました。まず、実測の価値です。ベンチマークを行うことで、予想外の結果を発見することができました。次に、シンプルさの力です。理解しやすい実装の重要性を実感しました。また、プラットフォーム理解も重要です。ElmとJavaScript VMの特性を把握することが必要です。

### The Elm Architectureでの最適化

The Elm Architectureでの最適化についても学びました。Html.LazyやHtml.Keyedの活用が重要です。また、モデル設計の見直しや、データ構造の選択も重要なポイントです。

### 自作実装の価値

自作実装を行うことで、いくつかの価値ある経験を得ることができました。まず、教育効果です。内部動作を深く理解することができました。次に、カスタマイズ性です。特定用途への最適化が可能になりました。また、関数型プログラミングの実践的な学習機会にもなりました。

## まとめ

最後に、今回の取り組みをまとめさせていただきます。

### 主な成果

今回の取り組みで、いくつかの成果を得ることができました。まず、List型を使わない完全なArray実装を実現しました。次に、ヒープソート、マージソート、クイックソートの比較を行いました。また、理論と実践の違いを体験することができました。

### 効果的な最適化アプローチ

効果的な最適化アプローチとして、段階的な改善が重要です。ListからArray、Dict、そしてロジック改善へと進めていきました。また、測定主導の開発も重要です。ベンチマークで効果を確認しながら進めました。さらに、シンプルさの価値も実感しました。可読性とパフォーマンスのバランスを取ることが重要です。

### 今後の展望

今後の展望として、より大規模データでの検証を行いたいと考えています。また、WebWorkersやWebAssemblyとの比較も興味深い課題です。さらに、実用アプリケーションでの活用も検討していきたいと思います。

サンプルコードとベンチマーク結果は、GitHubリポジトリで公開していますので、ご興味のある方はご覧ください。

ご清聴ありがとうございました。

## 参考リソース
- [Elm公式ドキュメント](https://elm-lang.org/docs)
- [elm-benchmark](https://package.elm-lang.org/packages/elm-explorations/benchmark/latest/)
- [elm-csv](https://package.elm-lang.org/packages/elm-community/csv/latest/)
- [elm-json-decode](https://package.elm-lang.org/packages/elm/json/latest/)
- [Elm最適化ガイド](https://guide.elm-lang.org/optimization/)

## 技術的な前提知識
- Elmの基本的な構文と概念
- 関数型プログラミングの基礎
- パフォーマンス最適化の一般概念

## 補足資料
- より高度な最適化テクニック集
  - lazy evaluationパターン
  - データ構造の選択ガイド
  - DOM操作のパフォーマンスに関する詳細
- The Elm Architectureとパフォーマンスの関係
- ベンチマーク結果の詳細データ

## デモと資料
- サンプルコードとベンチマーク結果はこのリポジトリで公開
- スライド資料は発表後にアップロード予定 
